name: CI/CD Python Typ√© + IA Fran√ßais

on:
  push:
    branches: [ main , feature/*, devin ]
  pull_request:
    branches: [ main , feature/*, devin ]

jobs:
  check-and-email:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run MyPy (v√©rification des types)
        id: mypy-check
        continue-on-error: true
        run: |
          python -m mypy main.py > mypy_output.txt 2>&1 || echo "MyPy a d√©tect√© des erreurs"
          cat mypy_output.txt

      - name: Run Ruff (linting)
        id: ruff-check
        continue-on-error: true
        run: |
          python -m ruff check . > ruff_output.txt 2>&1 || echo "Ruff a d√©tect√© des erreurs"
          cat ruff_output.txt

      - name: V√©rifier fautes de fran√ßais dans le message de commit
        id: check-french
        continue-on-error: true
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
        run: |
          python - <<EOF
          from openai import OpenAI
          import os
          import sys

          # Utiliser Groq avec l'API compatible OpenAI
          client = OpenAI(
            api_key=os.getenv("GROQ_API_KEY"),
            base_url="https://api.groq.com/openai/v1"
          )
          commit_msg = """${{ github.event.head_commit.message }}"""

          response = client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=[
              {"role": "system", "content": "Tu es un correcteur de fran√ßais. R√©ponds uniquement 'OK' si le message est parfait. Sinon, r√©ponds 'ERREUR: [liste des fautes]'."},
              {"role": "user", "content": commit_msg}
            ],
            temperature=0
          )
          result = response.choices[0].message.content.strip()
          print(result)

          # Sauvegarder le r√©sultat dans un fichier
          with open("french_check.txt", "w", encoding="utf-8") as f:
            f.write(result)

          if result.startswith("ERREUR"):
            print("Fautes d√©tect√©es")
            sys.exit(1)
          else:
            print("Fran√ßais parfait !")
          EOF

      - name: G√©n√©rer rapport HTML
        if: always()
        env:
          COMMIT_MSG: ${{ github.event.head_commit.message }}
          COMMITTER_NAME: ${{ github.event.head_commit.author.name }}
        run: |
          python generate_html_report.py

      - name: Envoyer notification Discord
        if: always()
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          COMMIT_MSG: ${{ github.event.head_commit.message }}
          COMMITTER_NAME: ${{ github.event.head_commit.author.name }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          python send_discord_notification.py || true

      - name: Auto-Fix et cr√©er Pull Request
        if: failure() || steps.mypy-check.outcome == 'failure' || steps.ruff-check.outcome == 'failure'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Configurer Git
          git config --global user.name "CI Bot"
          git config --global user.email "ci-bot@github.com"

          # Cr√©er une branche pour les corrections
          BRANCH_NAME="auto-fix/$(date +%Y%m%d-%H%M%S)"
          git checkout -b "$BRANCH_NAME"

          # Appliquer les corrections automatiques
          python auto_fix.py || true

          # V√©rifier s'il y a des changements
          if git diff --quiet; then
            echo "‚ö†Ô∏è Aucune correction automatique n'a pu √™tre appliqu√©e"
            exit 0
          fi

          # Committer les changements
          git add .
          git commit -m "ü§ñ Auto-fix: Corrections automatiques des erreurs Ruff

          Corrections appliqu√©es automatiquement par le CI/CD:
          - Suppression des imports inutilis√©s
          - Correction du formatage du code
          - Tri des imports

          G√©n√©r√© automatiquement par GitHub Actions"

          # Pousser la branche
          git push origin "$BRANCH_NAME"

          # Cr√©er une Pull Request avec GitHub CLI
          gh pr create \
            --title "ü§ñ Auto-Fix: Corrections automatiques" \
            --body "## ü§ñ Corrections Automatiques

          Ce PR a √©t√© cr√©√© automatiquement par le syst√®me CI/CD.

          ### ‚úÖ Corrections appliqu√©es:
          - Suppression des imports inutilis√©s
          - Formatage du code selon les standards Ruff
          - Tri des imports

          ### üìä D√©tails:
          - **Commit original**: ${{ github.event.head_commit.message }}
          - **Auteur**: ${{ github.event.head_commit.author.name }}
          - **Branche**: \`$BRANCH_NAME\`

          ### üîç Actions requises:
          - [ ] V√©rifier les changements
          - [ ] Merger si tout est OK
          - [ ] Corriger manuellement les erreurs MyPy (si pr√©sentes)

          ---
          ü§ñ G√©n√©r√© automatiquement par GitHub Actions" \
            --base main \
            --head "$BRANCH_NAME"

          echo "‚úÖ Pull Request cr√©√©e avec succ√®s!"

      - name: Envoyer email de f√©licitations (si tout est OK)
        if: success()
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
          EMAIL_PORT: ${{ secrets.EMAIL_PORT }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          COMMITTER_EMAIL: ${{ github.event.head_commit.author.email }}
        run: |
          python - <<EOF
          import os
          from openai import OpenAI
          from smtplib import SMTP
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart

          # Utiliser Groq avec l'API compatible OpenAI
          client = OpenAI(
            api_key=os.getenv("GROQ_API_KEY"),
            base_url="https://api.groq.com/openai/v1"
          )
          committer = os.getenv("COMMITTER_EMAIL")
          commit_msg = """${{ github.event.head_commit.message }}"""

          # G√©n√®re un email personnalis√©
          response = client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=[
              {"role": "system", "content": "Tu es un assistant chaleureux. G√©n√®re un email de f√©licitations en fran√ßais, professionnel mais amical, adapt√© √† la culture du d√©veloppeur. Utilise le pr√©nom si possible."},
              {"role": "user", "content": f"Message de commit: {commit_msg}\nEmail du committer: {committer}"}
            ]
          )
          body = response.choices[0].message.content

          msg = MIMEMultipart()
          msg['From'] = os.getenv("EMAIL_USER")
          msg['To'] = committer
          msg['Subject'] = "F√©licitations pour ton commit parfait !"

          msg.attach(MIMEText(body, 'plain', 'utf-8'))

          server = SMTP(os.getenv("EMAIL_HOST"), int(os.getenv("EMAIL_PORT")))
          server.starttls()
          server.login(os.getenv("EMAIL_USER"), os.getenv("EMAIL_PASSWORD"))
          server.send_message(msg)
          server.quit()
          print("Email envoy√© avec succ√®s !")
          EOF

      - name: Envoyer email de correction (si erreurs d√©tect√©es)
        if: failure() || steps.mypy-check.outcome == 'failure' || steps.ruff-check.outcome == 'failure' || steps.check-french.outcome == 'failure'
        env:
          GROQ_API_KEY: ${{ secrets.GROQ_API_KEY }}
          EMAIL_HOST: ${{ secrets.EMAIL_HOST }}
          EMAIL_PORT: ${{ secrets.EMAIL_PORT }}
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_PASSWORD: ${{ secrets.EMAIL_PASSWORD }}
          COMMITTER_EMAIL: ${{ github.event.head_commit.author.email }}
          COMMITTER_NAME: ${{ github.event.head_commit.author.name }}
        run: |
          python - <<EOF
          import os
          from openai import OpenAI
          from smtplib import SMTP
          from email.mime.text import MIMEText
          from email.mime.multipart import MIMEMultipart
          from email.mime.base import MIMEBase
          from email import encoders

          # Utiliser Groq avec l'API compatible OpenAI
          client = OpenAI(
            api_key=os.getenv("GROQ_API_KEY"),
            base_url="https://api.groq.com/openai/v1"
          )
          committer = os.getenv("COMMITTER_EMAIL")
          committer_name = os.getenv("COMMITTER_NAME", "D√©veloppeur")
          commit_msg = """${{ github.event.head_commit.message }}"""

          # Lire les r√©sultats des v√©rifications
          mypy_errors = ""
          ruff_errors = ""
          french_errors = ""

          try:
            with open("mypy_output.txt", "r", encoding="utf-8") as f:
              mypy_errors = f.read()
          except:
            pass

          try:
            with open("ruff_output.txt", "r", encoding="utf-8") as f:
              ruff_errors = f.read()
          except:
            pass

          try:
            with open("french_check.txt", "r", encoding="utf-8") as f:
              french_errors = f.read()
          except:
            pass

          # Construire le rapport d'erreurs
          error_report = f"""
          Commit: {commit_msg}
          Auteur: {committer_name}

          ERREURS D√âTECT√âES:

          MyPy (v√©rification des types):
          {mypy_errors if mypy_errors else "‚úÖ Aucune erreur"}

          Ruff (linting et style):
          {ruff_errors if ruff_errors else "‚úÖ Aucune erreur"}

          V√©rification du fran√ßais:
          {french_errors if french_errors else "‚úÖ Aucune erreur"}
          """

          # G√©n√©rer suggestions de correction avec l'IA
          suggestions_prompt = f"""Analyse ces erreurs et g√©n√®re des suggestions de correction concr√®tes avec des exemples de code.
          Pour chaque erreur, montre:
          ‚ùå Code actuel (avec l'erreur)
          ‚úÖ Code corrig√© (suggestion)

          Erreurs:\n{error_report}

          Format: Utilise des blocs de code Python clairs et concis."""

          suggestions_response = client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=[
              {"role": "system", "content": "Tu es un expert Python. G√©n√®re des suggestions de correction avec des exemples de code avant/apr√®s."},
              {"role": "user", "content": suggestions_prompt}
            ],
            temperature=0.3
          )
          code_suggestions = suggestions_response.choices[0].message.content

          # G√©n√©rer un email personnalis√© avec l'IA
          response = client.chat.completions.create(
            model="llama-3.3-70b-versatile",
            messages=[
              {"role": "system", "content": f"Tu es un mentor bienveillant en d√©veloppement. G√©n√®re un email en fran√ßais pour {committer_name}, professionnel mais encourageant. Adapte le ton √† la culture francophone (chaleureux, p√©dagogique). Explique les erreurs de mani√®re simple, mentionne qu'il y a des suggestions de code ci-dessous, et termine par une phrase motivante. Maximum 200 mots."},
              {"role": "user", "content": f"Rapport d'erreurs:\n{error_report}"}
            ],
            temperature=0.7
          )
          body = response.choices[0].message.content

          msg = MIMEMultipart()
          msg['From'] = os.getenv("EMAIL_USER")
          msg['To'] = committer
          msg['Subject'] = f"‚ö†Ô∏è Corrections n√©cessaires pour ton commit - {committer_name}"

          # Ajouter le corps de l'email + suggestions + rapport d√©taill√©
          full_body = f"""{body}

          {'='*60}
          üí° SUGGESTIONS DE CORRECTION:
          {'='*60}
          {code_suggestions}

          {'='*60}
          üìä RAPPORT D√âTAILL√â:
          {'='*60}
          {error_report}
          """
          msg.attach(MIMEText(full_body, 'plain', 'utf-8'))

          # Joindre le rapport HTML
          try:
            with open("ci_report.html", "rb") as f:
              part = MIMEBase("application", "octet-stream")
              part.set_payload(f.read())
              encoders.encode_base64(part)
              part.add_header("Content-Disposition", "attachment; filename=ci_report.html")
              msg.attach(part)
              print("‚úÖ Rapport HTML joint √† l'email")
          except Exception as e:
            print(f"‚ö†Ô∏è Impossible de joindre le rapport HTML: {e}")

          server = SMTP(os.getenv("EMAIL_HOST"), int(os.getenv("EMAIL_PORT")))
          server.starttls()
          server.login(os.getenv("EMAIL_USER"), os.getenv("EMAIL_PASSWORD"))
          server.send_message(msg)
          server.quit()
          print("Email de correction envoy√© avec succ√®s !")
          EOF